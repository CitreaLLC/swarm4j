package citrea.swarm4j.storage;

import citrea.swarm4j.model.Host;
import citrea.swarm4j.model.SwarmException;
import citrea.swarm4j.model.Syncable;
import citrea.swarm4j.model.callback.OpRecipient;
import citrea.swarm4j.model.callback.Peer;
import citrea.swarm4j.model.spec.Spec;
import citrea.swarm4j.model.spec.SpecMap;
import citrea.swarm4j.model.spec.SpecToken;
import citrea.swarm4j.model.value.JSONValue;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * Created with IntelliJ IDEA.
 *
 * @author aleksisha
 *         Date: 25.08.2014
 *         Time: 00:55
 */
public abstract class Storage implements Peer {

    protected Host host;
    protected SpecToken id;
    protected String lastTs = "";
    protected int tsSeq = 0;
    private String version;
    private long clockOffset = 0L;

    public void setHost(Host host) {
        this.host = host;
    }

    /**
     * Returns an unique Lamport timestamp on every invocation.
     * Swarm employs 30bit integer Unix-like timestamps starting epoch at
     * 1 Jan 2010. Timestamps are encoded as 5-char base64 tokens; in case
     * several events are generated by the same process at the same second
     * then sequence number is added so a timestamp may be more than 5
     * chars. The id of the Host (+user~session) is appended to the ts.
     */
    public String time() {
        long d = new Date().getTime() - SpecToken.EPOCH + this.clockOffset;
        String ts = SpecToken.int2base((int) (d / 1000), 5);
        String res = ts;
        if (ts.equals(this.lastTs)) {
            res += SpecToken.int2base(++this.tsSeq, 2); // max ~4000Hz
        } else {
            this.tsSeq = 0;
        }
        res += '+' + this.getTypeId().getId().getBody();
        this.lastTs = ts;
        this.version = "!" + res;
        return res;
    }

    public String getVersion() {
        return this.version;
    }

    @Override
    public void deliver(Spec spec, JSONValue value, OpRecipient source) throws SwarmException {
        final SpecToken op = spec.getOp();
        if (Syncable.ON.equals(op)) {
            this.on(spec, value, source);
        } else if (Syncable.OFF.equals(op)) {
            this.off(spec, source);
        } else if (Syncable.PATCH.equals(op)) {
            this.patch(spec, value);
        } else {
            this.op(spec, value, source);
        }
    }

    protected abstract void on(Spec spec, JSONValue value, OpRecipient source) throws SwarmException;

    protected abstract void off(Spec spec, OpRecipient source) throws SwarmException;

    protected abstract void patch(Spec spec, JSONValue patch) throws SwarmException;

    protected abstract void appendToLog(Spec ti, JSONValue verop2val) throws SwarmException;

    public void op(Spec spec, JSONValue val, OpRecipient source) throws SwarmException {
        Spec ti = spec.getTypeId();
        Spec vo = spec.getVersionOp();
        Map<String, JSONValue> o = new HashMap<String, JSONValue>();
        o.put(vo.toString(), val);
        this.appendToLog(ti, new JSONValue(o));
    }

    /**
     * Derive version vector from a state of a Syncable object.
     * This is not a method as it needs to be applied to a flat JSON object.
     * @see citrea.swarm4j.model.Syncable#version()
     * @see citrea.swarm4j.model.spec.SpecMap
     * @return string representation of SpecMap
     */
    public static String stateVersionVector(JSONValue state) {
        StringBuilder str = new StringBuilder();
        JSONValue version = state.getFieldValue("_version");
        if (!version.isEmpty()) {
            str.append(version.getValueAsStr());
        }
        JSONValue vector = state.getFieldValue("_vector");
        if (!vector.isEmpty()) {
            str.append(version.getValueAsStr());
        }
        JSONValue oplog = state.getFieldValue("_oplog");
        for (String spec : oplog.getFieldNames()) {
            str.append(spec);
        }
        JSONValue tail = state.getFieldValue("_tail");
        for (String spec : tail.getFieldNames()) {
            str.append(spec);
        }
        return new SpecMap(str.toString()).toString();
    }
}
