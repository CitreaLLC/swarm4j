package citrea.swarm4j.storage;

import citrea.swarm4j.model.Host;
import citrea.swarm4j.model.QueuedOperation;
import citrea.swarm4j.model.SwarmException;
import citrea.swarm4j.model.Syncable;
import citrea.swarm4j.model.callback.OpRecipient;
import citrea.swarm4j.model.callback.Peer;
import citrea.swarm4j.model.spec.Spec;
import citrea.swarm4j.model.spec.SpecMap;
import citrea.swarm4j.model.spec.SpecToken;
import citrea.swarm4j.model.value.JSONValue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * Created with IntelliJ IDEA.
 *
 * @author aleksisha
 *         Date: 25.08.2014
 *         Time: 00:55
 */
public abstract class Storage implements Peer, Runnable {

    protected Logger logger = LoggerFactory.getLogger(Storage.class);

    public final BlockingQueue<QueuedOperation> queue = new LinkedBlockingQueue<QueuedOperation>();
    private Thread queueThread;

    protected Host host;
    protected SpecToken id;
    protected String lastTs = "";
    protected int tsSeq = 0;
    private String version;
    private long clockOffset = 0L;

    protected Storage(SpecToken id) {
        this.id = id;
    }

    public void setHost(Host host) {
        if (this.host != null) throw new IllegalStateException("host can be set only once");

        this.host = host;
    }

    /**
     * Returns an unique Lamport timestamp on every invocation.
     * Swarm employs 30bit integer Unix-like timestamps starting epoch at
     * 1 Jan 2010. Timestamps are encoded as 5-char base64 tokens; in case
     * several events are generated by the same process at the same second
     * then sequence number is added so a timestamp may be more than 5
     * chars. The id of the Host (+user~session) is appended to the ts.
     */
    public String time() {
        long d = new Date().getTime() - SpecToken.EPOCH + this.clockOffset;
        String ts = SpecToken.int2base((int) (d / 1000), 5);
        String res = ts;
        if (ts.equals(this.lastTs)) {
            res += SpecToken.int2base(++this.tsSeq, 2); // max ~4000Hz
        } else {
            this.tsSeq = 0;
        }
        res += '+' + this.getTypeId().getId().getBody();
        this.lastTs = ts;
        this.version = "!" + res;
        return res;
    }

    public String getVersion() {
        return this.version;
    }

    @Override
    public void deliver(Spec spec, JSONValue value, OpRecipient source) throws SwarmException {
        if (queueThread != Thread.currentThread()) {
            // queue
            try {
                queue.put(new QueuedOperation(spec, value, source));
            } catch (InterruptedException e) {
                throw new SwarmException(e.getMessage(), e);
            }
        } else {
            logger.debug("{}.deliver({}, {}, {})", this, spec, value, source);
            final SpecToken op = spec.getOp();
            if (Syncable.ON.equals(op)) {
                this.on(spec, value, source);
            } else if (Syncable.OFF.equals(op)) {
                this.off(spec, source);
            } else if (Syncable.PATCH.equals(op)) {
                this.patch(spec, value);
            } else {
                this.op(spec, value, source);
            }
        }
    }

    protected abstract void on(Spec spec, JSONValue value, OpRecipient source) throws SwarmException;

    protected abstract void off(Spec spec, OpRecipient source) throws SwarmException;

    protected abstract void patch(Spec spec, JSONValue patch) throws SwarmException;

    public void op(Spec spec, JSONValue val, OpRecipient source) throws SwarmException {
        Spec ti = spec.getTypeId();
        Spec vo = spec.getVersionOp();
        Map<String, JSONValue> o = new HashMap<String, JSONValue>();
        o.put(vo.toString(), val);
        this.appendToLog(ti, new JSONValue(o));
    }

    protected abstract void appendToLog(Spec ti, JSONValue verop2val) throws SwarmException;

    /**
     * Derive version vector from a state of a Syncable object.
     * This is not a method as it needs to be applied to a flat JSON object.
     * @see citrea.swarm4j.model.Syncable#version()
     * @see citrea.swarm4j.model.spec.SpecMap
     * @return string representation of SpecMap
     */
    public static String stateVersionVector(JSONValue state) {
        StringBuilder str = new StringBuilder();
        JSONValue version = state.getFieldValue("_version");
        if (!version.isEmpty()) {
            str.append(version.getValueAsStr());
        }
        JSONValue vector = state.getFieldValue("_vector");
        if (!vector.isEmpty()) {
            str.append(version.getValueAsStr());
        }
        JSONValue oplog = state.getFieldValue("_oplog");
        for (String spec : oplog.getFieldNames()) {
            str.append(spec);
        }
        JSONValue tail = state.getFieldValue("_tail");
        for (String spec : tail.getFieldNames()) {
            str.append(spec);
        }
        return new SpecMap(str.toString()).toString();
    }

    @Override
    public SpecToken getPeerId() {
        return id;
    }

    @Override
    public void setPeerId(SpecToken id) {
        this.id = id;
    }

    public synchronized boolean ready() {
        return queueThread != null;
    }

    @Override
    public void run() {
        synchronized (this) {
            if (queueThread != null) {
                throw new IllegalStateException("Can't run the single host more than once");
            }
            queueThread = Thread.currentThread();
        }
        queueThread.setName("Stor" + this.getPeerId().toString());

        logger.info("started");
        try {
            while (!queueThread.isInterrupted()) {
                QueuedOperation op = queue.take();
                if (op == null) continue;

                try {
                    this.deliver(op.getSpec(), op.getValue(), op.getPeer());
                } catch (SwarmException e) {
                    //TODO fatal exception
                    logger.warn("Error processing operation: {}", op, e);
                }
            }
        } catch (InterruptedException e) {
            //ignore
        }
        logger.info("finished");
    }

    public void start() {
        new Thread(this).start();
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + getPeerId();
    }
}
