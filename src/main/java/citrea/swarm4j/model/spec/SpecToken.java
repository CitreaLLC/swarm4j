package citrea.swarm4j.model.spec;

import java.util.Comparator;
import java.util.Date;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;

/**
 * One token id from specifier.
 *
 * @see Spec
 *
 * Created with IntelliJ IDEA.
 * @author aleksisha
 *         Date: 27/10/13
 *         Time: 12:54
 */
public class SpecToken implements Comparable<SpecToken> {

    public static final String RS_TOK = "[0-9A-Za-z_~]+";
    public static final String RS_TOK_EXT = "^(=)(?:\\+(=))?$".replaceAll("=", RS_TOK);
    public static final String NO_AUTHOR = "swarm";

    public static final long EPOCH = 1262275200000L; // 1 Jan 2010 (milliseconds)
    public static final SpecToken ZERO_VERSION = new SpecToken("!0");

    // "bare+ext"
    private String str;
    private boolean parsed;

    // parsed parts
    private SpecQuant quant;
    private String bare;
    private String ext;

    public SpecToken(String tokenAsString) {
        this.str = tokenAsString;
        this.parsed = false;
    }

    public SpecToken(SpecQuant quant, String body) {
        this.quant = quant;
        parseBody(body);
        this.parsed = true;
        this.str = quant.code + this.bare + (NO_AUTHOR.equals(this.ext) ? "" : "+" + this.ext);
    }

    public SpecToken(SpecQuant quant, String bare, String ext) {
        this.quant = quant;
        this.bare = bare;
        this.ext = (ext != null && ext.length() > 0) ? ext : NO_AUTHOR;
        this.parsed = true;
        this.str = quant.code + this.bare + (NO_AUTHOR.equals(this.ext) ? "" : "+" + this.ext);
    }

    /** Swarm employs 30bit integer Unix-like timestamps starting epoch at
     *  1 Jan 2010. Timestamps are encoded as 5-char base64 tokens; in case
     *  several events are generated by the same process at the same second
     *  then sequence number is added so a timestamp may be more than 5
     *  chars.
     */
    public static String date2ts(Date date) {
        long time = date.getTime();
        time -= SpecToken.EPOCH;
        return int2base((int) (time / 1000), 5);
    }

    private static final String PADDING_ZEROS = "0000000000000000";

    public static String int2base(int i, Integer padlen) {
        if (i < 0 || i >= (1 << 30)) {
            throw new IllegalArgumentException("out of range");
        }
        // TODO check realizations for efficiency
        /* (1)
        String ret = "";
        int togo = padlen || 5;
        for (; i || (togo > 0); i >>= 6, togo--) {
            ret = Spec.BASE64.charAt(i & 63) + ret;
        }
        return ret;
        */

        // (2)
        String ret = "";
        while (i != 0) {
            ret = Spec.BASE64.charAt(i & 63) + ret;
            i >>= 6;
        }
        if (padlen == null) {
            padlen = 5;
        }
        if (ret.length() < padlen) {
            ret = PADDING_ZEROS.substring(0, padlen - ret.length()) + ret;
        }
        return ret;
    }

    public static int base2int(String token) {
        Matcher m = Spec.RE_BASE64.matcher(token);
        if (!m.matches()) {
            throw new IllegalArgumentException("Not a base64 token");
        }
        int ret = 0;
        MatchResult mr = m.toMatchResult();
        for (int i = mr.groupCount() - 1, shift = 0; i >= 0; i++, shift += 6) {
            ret += Spec.BASE64.indexOf(mr.group(i)) << shift;
        }
        return ret;
    }

    private void ensureParsed() {
        if (parsed) { return; }
        this.quant = SpecQuant.byCode(str.charAt(0));
        parseBody(str.substring(1));
        this.parsed = true;
    }

    private void parseBody(String body) {
        int pos = body.indexOf("+");
        this.bare = (pos > -1 ? body.substring(0, pos) : body);
        this.ext = (pos > -1 ? body.substring(pos + 1) : NO_AUTHOR);
    }

    public SpecQuant getQuant() {
        return (parsed ? quant : SpecQuant.byCode(str.charAt(0)));
    }

    public String getBody() {
        return str.substring(1);
    }

    /**
     * @return bare part of spec token
     */
    public String getBare() {
        ensureParsed();
        return bare;
    }

    /**
     * @return ext part of spec token
     */
    public String getExt() {
        ensureParsed();
        return ext;
    }

    public SpecToken overrideQuant(SpecQuant quant) {
        ensureParsed();
        return new SpecToken(quant, bare, ext);
    }

    public SpecToken overrideBare(String bare) {
        ensureParsed();
        return new SpecToken(quant, bare, ext);
    }

    public SpecToken overrideExt(String ext) {
        ensureParsed();
        SpecToken res;
        if (ext != null && ext.length() > 0) {
            res = new SpecToken(quant, bare, ext);
        } else {
            res = new SpecToken(quant, bare, NO_AUTHOR);
        }
        return res;
    }

    @Override
    public String toString() {
        return this.str;
    }

    @Override
    public int hashCode() {
        return this.str.hashCode();
    }

    public boolean equals(String token) {
        return this.str.equals(token);
    }

    @Override
    public boolean equals(Object o) {
        return equals(String.valueOf(o));
    }

    @Override
    public int compareTo(SpecToken other) {
        if (this.str == null) {
            return other == null ? 0 : -1;
        } else {
            return other == null ? 1 : this.str.compareTo(other.str);
        }
    }

    public static Comparator<SpecToken> ORDER_BY_QUANT = new Comparator<SpecToken>() {

        @Override
        public int compare(SpecToken left, SpecToken right) {
            if (left == null) {
                return right == null ? 0 : -1;
            } else {
                if (right == null) {
                    return 1;
                }
                return left.getQuant().compareTo(right.getQuant());
            }
        }
    };
}
